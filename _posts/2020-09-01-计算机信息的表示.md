---
layout: mypost
title: 计算机信息的表示
categories: [计算机]
---

## 字数据大小
每台计算机都有一个字长（word size），指明指针数据的标称大小（nominal size）。因为虚拟地址就是以这样的一个字来编码的，所以字长决定的最重要的参数就是虚拟地址空间的大小。
32 位字长限制虚拟地址空间为 4GB，64 位字长使得虚拟地址空间为 16EB。

## 寻址和字节顺序
机器在内存中按照从最低有效字节的顺序存储称为小端法（little endian），机器按照从高有效字节到最低有效字节的顺序存储称为大端法（big endian）。  

举个例子，假设变量 x 的类型为 int，占 4 个字节，位于地址 0x100 处，值为 0x01234567：int x = 0x1234567;
### 大端法  

         ··· | 0x100 | 0x101 | 0x102 | 0x103 | ··· 
       —————————————————————————————————————————————
         ··· |   01  |   23  |   45  |   67  | ··· 


### 小端法

         ··· | 0x100 | 0x101 | 0x102 | 0x103 | ···
       —————————————————————————————————————————————
         ··· |   67  |   45  |   23  |   01  | ···
         
### 代码验证
下面的代码能够验证机器的字节顺序。
```c
#include <stdio.h>

typedef unsigned char *byte_pointer;

void show_bytes(byte_pointer start, size_t len){
    size_t i;
    for(i = 0; i < len; i ++)
        printf(" %.2x", start[i]);
    printf("\n");
}

void show_int(int x) {
    show_bytes((byte_pointer) &x, sizeof(int));    
}

void show_float(float x) {
    show_bytes((byte_pointer) &x, sizeof(float));    
}

void show_pointer(void *x) {
    show_bytes((byte_pointer) &x, sizeof(void *));    
}

int main() {
    int a = 1;
    int c = -1;
    float b = 1.0;
    int *p = &a;

    // 打印整数的存储顺序
    show_int(c);
    show_int(a);
    // 打印浮点数的存储顺序
    show_float(b);
    // 打印指针地址的存储顺序
    show_pointer(p);

    return 0;    
}
```

运行两次程序的输出结果如下，可见我的机器是小端法的机器。注意最后一行的输出，两次的结果并不一致。这是两次运行程序，变量被分配的内存地址不一致的情况导致的，
但是长度是一致的。
```text
## 1
ff ff ff ff
01 00 00 00
00 00 80 3f
9c 00 50 43 fd 7f 00 00

## 2
ff ff ff ff
01 00 00 00
00 00 80 3f
cc ce 89 70 fe 7f 00 00
```

## 位运算
C 语言支持按位布尔运算：| 就是 OR，& 就是 AND，~ 就是 NOT，^ 就是 EXCLUSIVE-OR，这些运算能应用到任何整形的数据类型上。

## 逻辑运算
C 语言还提供了一组逻辑运算符 ||、&& 和 !，分别对用命题逻辑中的 OR、AND 和 NOT 运算。逻辑运算和位运算很容易混淆，但是它们的功能是完全不同的。
逻辑运算认为所有非零的参数都表示 TRUE，而参数 0 表示 FALSE。逻辑运算符 && 和 || 与它们对应的位运算符 & 和 | 之间的第二个重要的区别是，
如果对第一个参数求值就能确定表达式的结果，那么逻辑运算符就不会对第二个参数求值。

## 移位运算
### C 语言中支持两种移位运算  
> C 语言标准并没有明确定义对于有符号数应该使用哪种类型的右移，然而实际上几乎所有的编译器/机器组合都对有符号数使用算术右移。
> 还有一种情况是如果要移的位数 k 大于数的实际位数 w，则实际移的位数则是 k % w，这在 Java 语言中是强制的。

1. 左移 `<<`，舍弃最高位，在低位补 0。  
2. 逻辑右移 `>>` 舍弃最低位，在高位补 0。  
3. 算术右移 `>>` 舍弃最低位，如果最高位是 0，则在高位补 0；如果最高位是 1，则在高位补 1。  

### Java 语言中支持三种移位运算
1. 左移 `<<` 等同于 C 语言中的左移。
2. 逻辑右移 `>>>` 等同于 C 语言中的逻辑右移。
3. 算数右移 `>>` 等同于 C 语言中的算数右移。

<br/>
## 补码
C 和 Java 直接打印数在计算机中的字节存储的时候，会发现数是以补码的形式进行存储的。进行移位运算也是以补码的形式进行的。
以 8 位的整数表示 1 和 -1 为例，我们会发现 -1 的补码刚好等于 1 的反码加 1。其实所有的负数的补码都等于正数的反码加一。

| 数 | 补码 | 计算值 |  
| ---: | ---: | ---: |   
| 1 | 00000001 | 0 * 2^7 + 0 * 2^6 + ··· + 0 * 2^1 + 1 * 2^0 |   
| -1 | 11111111 | -1 * 2^7 + 1 * 2^6 + ··· + 1 * 2^1 + 1 * 2^0 |   

## 有符号和无符号之间的转换
同一类型的有符号和无符号的转换只改变位的解释。

## 截断和扩展
不会改变位的状态，只是改变位的解释模式。
```c
#include <stdio.h>

int main() {
	int x = 53191;
	printf("%10d: %x\n", x, x);
	short sx = (short) x;
	printf("%10d: %x\n", sx, sx);
	int y = sx;
	printf("%10d: %x\n", y, y);
}

// output: 
     53191: cfc7
    -12345: ffffcfc7
    -12345: ffffcfc7
```

## 关于有符号数和无符号数的建议
有符号数到无符号数的隐士强制类型转换导致了某些非直观的行为。而这些非直观的特性经常导致程序错误，并且这种包含隐式强制类型转换
的细微差别的错误很难发现。观察下面代码，当 `length` 等于零时，运行时会遇到一个内存错误，是因为无符号数的计算是
先将无符号数转换成有符号数相减，结果再转为无符号数。
```c
float sum_elements(float a[], unsinged length) {
    int i;
    float result = 0;

    for(i = 0; i <= length - 1; i ++)
        result += a[i];

    return result;
}
```

<br/>
> 任它桃李争欢赏，不为繁华易素心。