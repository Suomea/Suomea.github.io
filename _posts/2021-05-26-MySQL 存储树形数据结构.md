---
layout: mypost
title: MySQL 存储树形数据结构
categories: [MySQL]
---

## 一、问题描述
在一些业务场景下会有树形结构的数据需要存储到数据库中。最简单的是储存系统中的操作菜单，一般情况下数据库中会有一个 `menu` 表用来存
储菜单。菜单常见的都是两级，三级菜单比较少见。复杂一点的场景是存储像商品的分类或者其它分类相关的数据，可能会有 3 到 10 
层的深度。还有一种更复杂的情况就是理论上树的深度是无限的，就像 App 的拉新活动，新用户邀请老用户就会在数据库中记录下新老用户的绑定关系，
这样就能理论上 A 拉 B，B 拉 C，C 拉 D，这样一直下去，树的深度理论上就是无限大。  
<br/>
总结成两种情况：
- 第一种简单情况：这种情况下树的深度比较小，最好是 3 层以内，且确定不会超过 3 层。
- 第二种情况就是树的深度理论上无限大，即使在可预见的范围内大部分数据都在 10 层以内，但是业务或者理论上是允许无限深度的。

<br/>

> 为了简单，统一使用菜单存储来演示表的设计，菜单表为 `menu`。

## 二、简单情况处理
### 邻接表（Adjacency List）
对于深度比较小且层数固定的情况，可以在表中增加一个 `parent_id` 字段来表示上下级关系，数据库中的数据就像下面这样。 

| id | parent_id | menu_name | remark | 
| :--- | :--- | :--- | :--- |
| 1 | 0 | 用户管理 | 用户管理菜单 | 
| 2 | 1 | 用户列表 | 用户列表菜单 |
| 3 | 1 | 新增用户 | 新增用户菜单 |
| 4 | 0 | 订单管理 | 订单管理菜单 |
| 5 | 4 | 订单列表 | 订单列表菜单 |

<br/>

## 三、复杂情况处理
### 1. 路径枚举（Path Enumerations）
这种处理方法的逻辑是，在每条数据存储的时候记录下该数据在树中的路径，对于上面的菜单的数据存储下来就像下面这样。当然也可以根据需求在每条
记录中记录下当前节点在树中的深度。

| id | path | menu_name | remark | 
| :--- | :--- | :--- | :--- |
| 1 | /1 | 用户管理 | 用户管理菜单 | 
| 2 | /1/2 | 用户列表 | 用户列表菜单 |
| 3 | /1/3 | 新增用户 | 新增用户菜单 |
| 4 | /4 | 订单管理 | 订单管理菜单 |
| 5 | /4/5 | 订单列表 | 订单列表菜单 |

<br/>

### 2. 封闭表（Closure Table）
这种情况稍微复杂一点，不用在菜单表中增加额外的字段，但是需要用到另一张表来记录所有节点之间的上下级关系， `menu` 表的数据就像下面这样。

| id  | menu_name | remark |
| :--- | :--- | :--- |
| 1  | 用户管理 | 用户管理菜单 |
| 2  | 用户列表 | 用户列表菜单 |
| 3  | 新增用户 | 新增用户菜单 |
| 4 | 订单管理 | 订单管理菜单 |
| 5 | 订单列表 | 订单列表菜单 |
  
<br/>
还需要另一张表来记录 `menu` 表中各条记录的上下级关系，命名为 `menu_rel`，`depth` 代表下级节点与上级节点的深度，数据如下。如果想要查询
用户管理直接子菜单的 `id`，只要查询 `sup_id` 等于 1 且 `depth` 等于 1 的数据的 `sub_id` 就行了。 

| id  | sup_id | sub_id | depth | 
| :--- | :--- | :--- |
| 1  | 1 | 2 | 1 |
| 2  | 1 | 3 | 1 |
| 3  | 4 | 5 | 1 |

<br/>


> Therefore, never send to know for whom the bell tolls; It tolls for thee.

<br/>